%!TEX root = article.tex
%\section{Proof of Substring Concatenation Theorem}\label{app:substringconcat}
\section{Substring Concatenation}\label{app:substringconcat}
In this section, we give the proof of Theorem~\ref{thm:substringconcat}. Recall that we must store a string $R$ to answer substring concatenation queries: given two strings $x$ and $y$ return the location of an occurrence of $xy$ in $R$ or \texttt{NO} if no such occurrence exist.

%\todo{Fix this to be non-appendix-y}
%Belazzougui~et~al.~\cite{??} (see also \cite{goswami2015}) recently showed that: Given $A \subseteq [1,r]$ and any constant $\epsilon>0$, there is a data structure for $A$ using $O(|A|\log^\epsilon r)$ \emph{bits} of space that supports constant-time \emph{1D range emptiness queries}, i.e., given a query range $[a,b] \subseteq [1,r]$, is $A \cap [a,b]= \emptyset$? We now show how this leads to the claimed solution for the substring concatenation problem.

%Let $ST_R$ be the suffix tree of $R$. We can find the location in $ST_R$ corresponding to any substring of $R$ in $O(1)$ time using a constant-time weighted ancestor query on $ST_R$~\cite{gawrychowski2014weighted}.

To prove (i) we need the following definitions. For a substring $x$ of $R$, let $S(x)$ denote the suffixes of $R$ that have $x$ as a prefix, and let $S'(x) = \{i+|x| \mid i \in S(x) \wedge i+|x| \leq n\}$, i.e., $S'(x)$ are the suffixes of $R$ that are immediately preceded by $x$. Hence for two substrings $x$ and $y$, the suffixes that have $xy$ as a prefix are exactly $S'(x) \cap S(y)$. This is a 2D range reporting problem, but we can reduce to it to a 1D range emptiness problem in \emph{rank space} as follows.

Let $\rank(i)$ be the position of suffix $R[i...]$ in the lexicographic ordering of all suffixes of $R$, and let $\rank(A) = \{\rank(i) \mid i \in A\}$ for $A \subseteq \{1,n\}$. Then $xy$ is a substring of $R$ if and only if $\rank(S'(x)) \cap \rank(S(y)) = \emptyset$. Note that $\rank(S(y))$ is a range $[a,b] \subseteq [1,n]$, and we can determine this range in constant time for any substring $y$ using a constant-time weighted ancestor query on the suffix tree of $R$~\cite{gawrychowski2014weighted}. Consequently, we can decide if $xy$ is a substring of $R$ by a 1D range emptiness query on the set $\rank(S'(x))$. 

Belazzougui~et~al.~\cite{belazzougui2010fast} (see also \cite{goswami2015}) recently gave a 1D range emptiness data structure for a set $A \subseteq [1,r]$ using $O(|A|\log^\epsilon r)$ \emph{bits} of space, for any $\epsilon > 0$, and answering queries in constant time. We will build this data structure for $\rank(S'(x))$, but doing so for all substrings would require space $\tilde \Omega(r^2)$. 

To arrive at the space bound of $O(r\log^\epsilon r)$ (words), we employ the standard technique of a heavy path decomposition~\cite{harel1984fast} on the suffix tree of $R$, and only build the data structure for substrings of $R$ that correspond to the top of a heavy path. In this way, each suffix will appear in at most $\log r$ such data structures, leading to the claimed $O(r\log^\epsilon r)$ space bound (in words).

To answer a substring concatenation query with substrings $x$ and $y$, we first determine how far $y$ follows the heavy path in the suffix tree from the location where $x$ stops. This can be done in $O(1)$ time by a standard constant-time LCP query between two suffixes of $R$. We then proceeed to the top of the next heavy path, where we query the 1D range reporting data structure with the range $\rank(S(y'))$ where $y'$ is the remaining unmatched suffix of $y$. This completes the query, and the proof of (i).

The second solution (ii) is an implication of a result by Bille~et~al.~\cite{bille2014string}. Given the suffix tree $ST_R$ of $R$, an \emph{unrooted LCP query}~\cite{cole2004dictionary} takes a suffix $y$ and a location $\ell$ in $ST_R$ (either a node or a position on an edge) and returns the location in $ST_S$ that is reached after matching $y$ starting from location $\ell$. A substring concatenation query is straightforward to implement using two unrooted LCP queries, the first one starting at the root, and the second starting from the location returned by the first query. It follows from Bille~et~al.~\cite{bille2014string} that we can build a linear space data structure that supports unrooted LCP queries in time $O(\log \log r)$ thus completing the proof of (ii).